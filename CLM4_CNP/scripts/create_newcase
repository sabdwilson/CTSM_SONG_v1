#!/usr/bin/env perl 
#-----------------------------------------------------------------------------------------------
#
# create_newcase
#
# This utility allows the CCSM user to specify configuration
# options via a commandline interface.
#
#-----------------------------------------------------------------------------------------------

use strict;
#use warnings;
#use diagnostics;

use Cwd;
use English;
use Getopt::Long;
use IO::File;
use IO::Handle;


#-----------------------------------------------------------------------------------------------
# Setting autoflush (an IO::Handle method) on STDOUT helps in debugging.  It forces the test
# descriptions to be printed to STDOUT before the error messages start.

*STDOUT->autoflush();                  

#-----------------------------------------------------------------------------------------------
# Set the directory that contains the CCSM configuration scripts.  If the create_newcase command was
# issued using a relative or absolute path, that path is in $ProgDir.  Otherwise assume the
# command was issued from the current working directory.

(my $ProgName = $0) =~ s!(.*)/!!;      # name of this script
my $ProgDir = $1;                      # name of directory containing this script -- may be a
                                       # relative or absolute path, or null if the script is in
                                       # the user's PATH
my $cwd = getcwd();                    # current working directory
my $cfgdir;                            # absolute pathname of directory that contains this script
if ($ProgDir) { 
    $cfgdir = absolute_path($ProgDir);
} else {
    $cfgdir = $cwd;
}

my $ccsmroot = absolute_path("$cfgdir/..");
(-d "$ccsmroot")  or  die <<"EOF";
** Cannot find ccsmroot directory \"$ccsmroot\" **
EOF


#-----------------------------------------------------------------------------------------------
if ($#ARGV == -1) {
    usage();
}
my $machdir="$cfgdir/ccsm_utils/Machines";

#-----------------------------------------------------------------------------------------------

sub usage {
    die <<EOF;
SYNOPSIS
     create_newcase [options]
OPTIONS
     User supplied values are denoted in angle brackets (<>).  Any value that contains
     white-space must be quoted.  Long option names may be supplied with either single
     or double leading dashes.  A consequence of this is that single letter options may
     NOT be bundled.

     -case <name>         Specifies the case name (required).
     -compset <name>      Specify a CCSM compset (required).
     -res <name>          Specify a CCSM grid resolution (required).
     -mach <name>         Specify a CCSM machine (required).
     -mach_dir <path>     Specify the locations of the Machines directory (optional).
                          default: $machdir
     -confopts <value>    Specify some addition configuration options (optional)
                          _AOA = aoflux on atm grid
                          _AOE = aoflux on exch grid
                          _CG  = gregorian calendar
                          _D   = debug
                          _E   = esmf interfaces
                          _N*  = set NINST_ env value to * where * is an integer
                          _P*  = set pecount to specific values include T,S,M,L,X,1,1x1,16,16x1,4x4, etc
                          _R*  = single point mode, valid values are LA, LB, OA, OB
     -pecount <name>      Value of S,M,L,X1,X2 (optional). 
                          default: M, partially redundant with confopts _P
     -pes_file <name>     Full pathname of pes setup file to use (will overwrite default settings) (optional).
                          See sample_pes_file.xml for an example.
     -compset_file <name> Full pathname of compset setup file to use. (optional)
                          See sample_compset_file.xml for an example.
     -grid_file <name>    Full pathname of grid setup file to use (optional)
                          See sample_grid_file.xml for an example.
                          Note that compset components must support the new grid.
     -help [or -h]        Print usage to STDOUT (optional).
     -list                Only list valid values for compset, grid settings and machines (optional).
     -silent [or -s]      Turns on silent mode - only fatal messages issued (optional).
     -skip_rundb          Specifies that run database should not be prompted (optional).
     -verbose [or -v]     Turn on verbose echoing of settings made by create_newcase (optional).
     -xmlmode <name>      Sets format of xml files; normal or expert (optional). (default is normal) 

     The following arguments are required for a generic machine. Otherwise, they will be ignored. 

     -scratchroot <name>           ccsm executable directory (EXEROOT will be scratchroot/CASE) (char)
     -din_loc_root_csmdata <name>  ccsm input data root directory (char)
     -max_tasks_per_node <value>   maximum mpi tasks per machine node (integer)

     The following two arguments turn on single point mode. 
     If one is given -- both MUST be given.

     -pts_lat <value>     Latitude of single point to operate on (optional)
     -pts_lon <value>     Longitude of single point to operate on (optional)


EXAMPLES

  ./create_newcase -case mycase1 -res f19_g16 -compset B1850CN -mach bluefire -skip_rundb
  ./create_newcase -case mycase2 -res f19_g16 -compset B1850CN -mach bluefire -skip_rundb -confopts _D_P16
  ./create_newcase -case mycase3 -res f19_g16 -compset B1850CN -mach bluefire -skip_rundb -pts_lon -160 -pts_lat 40
  ./create_newcase -case mycase4 -res f19_g16 -compset MYCOMP -compset_file mycompset_file -mach bluefire -skip_rundb
  ./create_newcase -case mycase5 -res f19_g16 -compset B1850CN -mach bluefire -skip_rundb -confopts _CG_E -pes_file mypes_file

EOF
}

#-----------------------------------------------------------------------------------------------
# Save commandline
my $commandline = "create_newcase @ARGV";

#-----------------------------------------------------------------------------------------------
# Parse command-line options.
my %opts = (
              pts_lat => undef,
              pts_lon => undef,
              mach_dir => $machdir,
	    );
GetOptions(
    "case=s"                    => \$opts{'case'},
    "compset=s"                 => \$opts{'compset'},
    "confopts=s"                => \$opts{'confopts'},
    "res=s"                     => \$opts{'res'},
    "h|help"                    => \$opts{'help'},
    "list"                      => \$opts{'list'},
    "mach=s"                    => \$opts{'mach'},
    "mach_dir=s"                => \$opts{'mach_dir'},
    "pecount=s"                 => \$opts{'pecount'},
    "pes_file=s"                => \$opts{'pes_file'}, 
    "compset_file=s"            => \$opts{'compset_file'},
    "grid_file=s"               => \$opts{'grid_file'},
    "s|silent"                  => \$opts{'silent'},
    "skip_rundb"                => \$opts{'skip_rundb'},
    "testname=s"                => \$opts{'testname'},
    "testlist"                  => \$opts{'testlist'},
    "v|verbose"                 => \$opts{'verbose'},
    "xmlmode=s"                 => \$opts{'xmlmode'},
    "pts_lat=s"                 => \$opts{'pts_lat'},
    "pts_lon=s"                 => \$opts{'pts_lon'},
    "scratchroot=s"             => \$opts{'scratchroot'},
    "din_loc_root_csmdata=s"    => \$opts{'din_loc_root_csmdata'},
    "max_tasks_per_node=s"      => \$opts{'max_tasks_per_node'},
)  or usage();

# Give usage message.
usage() if $opts{'help'};

# Check for unparsed argumentss
if (@ARGV) {
    print "ERROR: unrecognized arguments: @ARGV\n";
    usage();
}

# Check that points mode is set correctly
if ( defined($opts{'pts_lat'}) && ! defined(($opts{'pts_lon'}) ) ) {
    print "ERROR: if pts_lat set -- pts_lon must also be set:  @ARGV\n";
    usage();
}
if ( defined($opts{'pts_lon'}) && ! defined(($opts{'pts_lat'}) ) ) {
    print "ERROR: if pts_lon set -- pts_lat must also be set:  @ARGV\n";
    usage();
}

# Check for manditory case input if not just listing valid values

my $case;
my $caseroot;
my $compset;
my $confopts;
my $grid;
my $mach;
my $testname;
my $pecount;
my $xmlmode;
if (!$opts{'list'}) {
    # Check for manditory case input
    if ($opts{'case'}) {
	$case = $opts{'case'};
    } else {
	die "ERROR: create_newcase must include the input argument, -case \n";
    }
    $caseroot = absolute_path("$case");
    if (-d $caseroot) {
	die "Caseroot directory $caseroot already exists \n";
    }
    my @dirs = split "/", $caseroot, -1;  # The -1 prevents split from stripping trailing nulls
    my $num = scalar @dirs;
    $case = $dirs[$num-1];

    # Check for manditory compset input
    if ($opts{'compset'}) {
	$compset = $opts{'compset'};
    } else {
	die "ERROR: create_newcase must include the input argument, -compset\n";
    }
    
    # Check for manditory grid input
    if ($opts{'res'}) {
	$grid = $opts{'res'};
    } else {
	die "ERROR: create_newcase must include the input argument, -res\n";
    }

    # Check for manditory machine input
    if ($opts{'mach'}) {
	$mach = $opts{'mach'};
        if ($mach =~ "generic") {
           if (!$opts{'scratchroot'}) {
              die "ERROR: create_newcase must include the argument -scratchroot for a generic machines \n";
           }
           if (!$opts{'din_loc_root_csmdata'}) {
	       die "ERROR: create_newcase must include the argument -din_loc_root_csmdata for a generic machines \n";
	   }
           if (!$opts{'max_tasks_per_node'}) {
              die "ERROR: create_newcase must include the argument -max_tasks_per_node for a generic machines \n";
           }
	   my $din_loc_root_csmdata = $opts{'din_loc_root_csmdata'};
	   (-d "$din_loc_root_csmdata")  or  die "Cannot find din_loc_root_csmdata directory $din_loc_root_csmdata";
       }
    } else {
	die "ERROR: create_newcase must include the input argument, -mach \n";
    }

    # Check for pecount setting
    $pecount = 'M';
    if ($opts{'pecount'}) {
	$pecount = $opts{'pecount'};
    }

    # Check for xmlmode setting
    $xmlmode = 'normal';
    if ($opts{'xmlmode'}) {
	$xmlmode = $opts{'xmlmode'};
    }

}
# Set machdir to default or value sent in on command line
$machdir=$opts{'mach_dir'};

# Define 3 print levels:
# 0 - only issue fatal error messages
# 1 - only informs what files are created (default)
# 2 - verbose
my $print = 1;
if ($opts{'silent'})  { $print = 0; }
if ($opts{'verbose'}) { $print = 2; }
my $eol = "\n";

my %cfg = ();           # build configuration

#
# Make sure we can find the Machines directory
# 

(-d "$machdir")   or  die <<"EOF";
** Cannot find ccsm Machines directory \"$machdir\" **
EOF


#-----------------------------------------------------------------------------------------------
# Make sure we can find required perl modules and configuration files.
# Look for them in the directory that contains the create_newcase script.

# Check for the configuration definition file.
my $config_def_file = "config_definition.xml";
(-f "$cfgdir/ccsm_utils/Case.template/$config_def_file")  or  die <<"EOF";
** Cannot find configuration definition file \"$config_def_file\" in directory 
    \"$cfgdir/ccsm_utils/Case.template/$config_def_file\" **
EOF

# Grid definition file.
my $grid_file = "";
if (defined $opts{'grid_file'}){
  $grid_file = $opts{'grid_file'};
  (-f $grid_file)  or  die <<"EOF";
  ** Cannot find user specified grid definition file \"$grid_file\"  **
EOF
} else {
  $grid_file = "$cfgdir/ccsm_utils/Case.template/config_grid.xml";
  (-f $grid_file)  or  die <<"EOF";
  ** Cannot find default grid definition file \"$grid_file\"  **
EOF
}

# Compset definition file.
my $compset_file="";
if (defined $opts{'compset_file'}){
  $compset_file = $opts{'compset_file'};
  (-f $compset_file)  or  die <<"EOF";
  ** Cannot find user specified compset parameters file \"$compset_file\"  **
EOF
} else {
  $compset_file = "$cfgdir/ccsm_utils/Case.template/config_compsets.xml";
  (-f $compset_file)  or  die <<"EOF";
  ** Cannot find default compset parameters file \"$compset_file\"  **
EOF
}


# Machines definition file.
my $machine_file = 'config_machines.xml';
(-f "$machdir/$machine_file")  or  die <<"EOF";
** Cannot find machine parameters file \"$machine_file\" in directory 
    \"$machdir\" **
EOF

# Tests file
my $tests_file = 'config_tests.xml';
(-f "$cfgdir/ccsm_utils/Testcases/$tests_file")  or  die <<"EOF";
** Cannot find test parameters file \"$tests_file\" in directory 
    \"$cfgdir/ccsm_utils/Testcases\" **
EOF

# The XML::Lite module is required to parse the XML configuration files.
(-f "$cfgdir/ccsm_utils/Tools/perl5lib/XML/Lite.pm")  or  die <<"EOF";
** Cannot find perl module \"XML/Lite.pm\" in directory 
    \"$cfgdir/ccsm_utils/Tools/perl5lib\" **
EOF

# The ConfigCase module provides utilities to store and manipulate the configuration.
(-f "$cfgdir/ccsm_utils/Case.template/ConfigCase.pm")  or  die <<"EOF";
** Cannot find perl module \"ConfigCase.pm\" in directory 
    \"$cfgdir/ccsm_utils/Case.template\" **
EOF

if ($print>=2) { print "Setting configuration directory to $cfgdir$eol"; }


#-----------------------------------------------------------------------------------------------
# Add $cfgdir/perl5lib to the list of paths that Perl searches for modules
my @dirs = (  $cfgdir, "$cfgdir/ccsm_utils/Case.template", "$cfgdir/ccsm_utils/Tools/perl5lib");
unshift @INC, @dirs;
require XML::Lite;
require ConfigCase;

#-----------------------------------------------------------------------------------------------
# If just listing valid values then exit after completion of lists
if ($opts{'testlist'}) {
    print_tests("$cfgdir/ccsm_utils/Testcases/config_tests.xml");
}
if ($opts{'list'}) {
    print_grids("$cfgdir/ccsm_utils/Case.template/config_grid.xml");
    print_compsets($compset_file);
    ConfigCase::print_machines("$machdir/config_machines.xml");
    if ($print>=2) { print "finished listing valid values, now exiting $eol"; }
    exit;
}

#-----------------------------------------------------------------------------------------------
# Query database for consistency if actually creating a case
if (!defined($opts{'skip_rundb'})) {
    my $sysmod = "env case=$case ${ccsmroot}/scripts/check_rundb"; 
    system($sysmod);
    if ($? != 0) { exit "must fix above problem first" }
#   if ($? == -1) {print "$sysmod failed: $!\n"; die}
}

#-----------------------------------------------------------------------------------------------
# print README/disclaimer file in scripts dir

my $readme;
$readme = `cat $cfgdir/README`;
print $readme;

#-----------------------------------------------------------------------------------------------
# Create new config object if not just listing valid values
my $cfg_ref = ConfigCase->new("$cfgdir/ccsm_utils/Case.template/$config_def_file"); 

#if ($print>=2) { print "A new config reference object was created$eol";}


#-----------------------------------------------------------------------------------------------
# First, Grid parameters
my ($grid_longname, $grid_shortname) = set_grid($grid_file, $grid, $cfg_ref);

if ($print>=2) { print "Horizontal grid specifier: $grid.$eol"; }

#-----------------------------------------------------------------------------------------------
# Second, Compset parameters
my $sysmod = "mkdir -p $caseroot"; 
system ($sysmod); if ($? == -1) {print "$sysmod failed: $!\n";}
my ($compset_longname, $compset_shortname) = set_compset($compset_file, $compset, 
							 $grid_longname, $grid_shortname, 
							 $cfg_ref, $caseroot);


if ($print>=2) { print "Compset specifier: $compset.$eol"; }

#-----------------------------------------------------------------------------------------------
# Third, Check if grid is valid for given compset
check_grid("$cfgdir/ccsm_utils/Case.template/config_grid.xml", $grid, 
	   $compset_longname);

if ($print>=2) { print "Grid is valid for input compset. $eol"; }

#-----------------------------------------------------------------------------------------------
# Fourth, Machine parameters
$cfg_ref->set_machine("$machdir/config_machines.xml", $mach, $print);

$cfg_ref->set('CCSM_MACHDIR', "$machdir");

if ($mach =~ "generic") {
    my $scratchroot  = "$opts{'scratchroot'}";
    my $exeroot = "$scratchroot/$case";
    $cfg_ref->set('EXEROOT'             , "$exeroot");  
    $cfg_ref->set('OBJROOT'             , "$exeroot");  
    $cfg_ref->set('LIBROOT'             , "$exeroot/lib");  
    $cfg_ref->set('DOUT_S_ROOT'         , "$exeroot/../archive/$case");  
    $cfg_ref->set('DIN_LOC_ROOT_CSMDATA',  $opts{'din_loc_root_csmdata'});  
    $cfg_ref->set('DIN_LOC_ROOT_CLMFORC', "$opts{'din_loc_root_csmdata'}/atm/datm7");  
    $cfg_ref->set('MAX_TASKS_PER_NODE'  ,  $opts{'max_tasks_per_node'});  
    $cfg_ref->set('GMAKE_J'             ,  "1");
}

if ($print>=2) { print "Machine specifier: $mach.$eol"; }

#-----------------------------------------------------------------------------------------------
# Fourth, Testname parameters
if (defined $opts{'testname'}) {
    $testname = $opts{'testname'};
    set_test("$cfgdir/ccsm_utils/Testcases/config_tests.xml", $testname, $cfg_ref);
}

#-----------------------------------------------------------------------------------------------
# Fifth, Configure Options
if (defined $opts{'confopts'}) {
    $confopts = $opts{'confopts'};
    set_confopts($confopts, $cfg_ref);
}

#-----------------------------------------------------------------------------------------------
# Sixth, Points mode settings on command line
if ( defined($opts{'pts_lat'}) && defined($opts{'pts_lon'}) ) {
   $cfg_ref->set('PTS_MODE',      "TRUE" );
   $cfg_ref->set('USE_MPISERIAL', "TRUE" );
   $cfg_ref->set('PTS_LAT',  $opts{'pts_lat'} );
   $cfg_ref->set('PTS_LON',  $opts{'pts_lon'} );
   $cfg_ref->set('ATM_NX', 0);
   $cfg_ref->set('ATM_NY', 0);
   $cfg_ref->set('LND_NX', 0);
   $cfg_ref->set('LND_NY', 0);
   $cfg_ref->set('ICE_NX', 0);
   $cfg_ref->set('ICE_NY', 0);
   $cfg_ref->set('OCN_NX', 0);
   $cfg_ref->set('OCN_NY', 0);
   $cfg_ref->set('GLC_NX', 0);
   $cfg_ref->set('GLC_NY', 0);
}

#-----------------------------------------------------------------------------------------------
# Determine pes for machine
# Always match on the full grid name and input compset name

my $grid_match = $cfg_ref->get('GRID'); 
my $compset_match = $cfg_ref->get('CCSM_SCOMPSET'); 
my $pmode  = $cfg_ref->get('PTS_MODE'); 
if ( $pmode eq "TRUE" ) {
   $pecount = 1;
}

##print "pes_match $grid_match $compset_match $mach $pecount \n";
my %pes_match = (grid_match    => $grid_match, 
		 compset_match => $compset_match,
		 mach_match    => $mach,
		 pecount       => $pecount);

my %decomp = (NTASKS_ATM=>16, NTHRDS_ATM=>1, ROOTPE_ATM=>0, NINST_ATM=>1,
	      NTASKS_LND=>16, NTHRDS_LND=>1, ROOTPE_LND=>0, NINST_LND=>1,
	      NTASKS_ICE=>16, NTHRDS_ICE=>1, ROOTPE_ICE=>0, NINST_ICE=>1,
	      NTASKS_OCN=>16, NTHRDS_OCN=>1, ROOTPE_OCN=>0, NINST_OCN=>1,
	      NTASKS_CPL=>16, NTHRDS_CPL=>1, ROOTPE_CPL=>0,
	      NTASKS_GLC=>16, NTHRDS_GLC=>1, ROOTPE_GLC=>0, NINST_GLC=>1,
              PIO_NUMTASKS=>-1, PIO_STRIDE=>-1, PIO_TYPENAME=>'netcdf',PIO_ROOT=>1,PIO_DEBUG_LEVEL=>0,
              ATM_PIO_NUMTASKS=>-99, ATM_PIO_STRIDE=>-99, ATM_PIO_TYPENAME=>'nothing',ATM_PIO_ROOT=>-99,
              LND_PIO_NUMTASKS=>-99, LND_PIO_STRIDE=>-99, LND_PIO_TYPENAME=>'nothing',LND_PIO_ROOT=>-99,
              ICE_PIO_NUMTASKS=>-99, ICE_PIO_STRIDE=>-99, ICE_PIO_TYPENAME=>'nothing',ICE_PIO_ROOT=>-99,
              OCN_PIO_NUMTASKS=>-99, OCN_PIO_STRIDE=>-99, OCN_PIO_TYPENAME=>'nothing',OCN_PIO_ROOT=>0,
              CPL_PIO_NUMTASKS=>-99, CPL_PIO_STRIDE=>-99, CPL_PIO_TYPENAME=>'nothing',CPL_PIO_ROOT=>-99,
              GLC_PIO_NUMTASKS=>-99, GLC_PIO_STRIDE=>-99, GLC_PIO_TYPENAME=>'nothing',GLC_PIO_ROOT=>-99,
              PES_LEVEL=>0);

# Reset the pes if a pes file is specified
if (defined $opts{'pes_file'}) {
    my $pes_file = $opts{'pes_file'};
    (-f "$pes_file")  or  die <<"EOF";
** Cannot find pes_file \"$pes_file\" ***
EOF
    $cfg_ref->reset_setup("$pes_file");

} else {
    
    if ($pecount =~ m!^([0-9]+)$!) {
      my $ntasks = $1;
      my $nthrds = 1;
#      print "tcx3 $ntasks $nthrds \n";
      $decomp{NTASKS_ATM} = $ntasks; $decomp{NTHRDS_ATM} = $nthrds;
      $decomp{NTASKS_LND} = $ntasks; $decomp{NTHRDS_LND} = $nthrds;
      $decomp{NTASKS_OCN} = $ntasks; $decomp{NTHRDS_OCN} = $nthrds;
      $decomp{NTASKS_ICE} = $ntasks; $decomp{NTHRDS_ICE} = $nthrds;
      $decomp{NTASKS_GLC} = $ntasks; $decomp{NTHRDS_GLC} = $nthrds;
      $decomp{NTASKS_CPL} = $ntasks; $decomp{NTHRDS_CPL} = $nthrds;
    } elsif ($pecount =~ m!^([0-9]+)x([0-9]+)$!) {
      my $ntasks = $1;
      my $nthrds = $2;
#      print "tcx3 $ntasks $nthrds \n";
      $decomp{NTASKS_ATM} = $ntasks; $decomp{NTHRDS_ATM} = $nthrds;
      $decomp{NTASKS_LND} = $ntasks; $decomp{NTHRDS_LND} = $nthrds;
      $decomp{NTASKS_OCN} = $ntasks; $decomp{NTHRDS_OCN} = $nthrds;
      $decomp{NTASKS_ICE} = $ntasks; $decomp{NTHRDS_ICE} = $nthrds;
      $decomp{NTASKS_GLC} = $ntasks; $decomp{NTHRDS_GLC} = $nthrds;
      $decomp{NTASKS_CPL} = $ntasks; $decomp{NTHRDS_CPL} = $nthrds;
    } else {
      set_pes("$machdir/config_pes.xml", \%pes_match, \%decomp, $pecount);
    }

# Special case for intrepid
    if($mach eq 'intrepid' && defined($opts{'testname'}) && $decomp{NTASKS_CPL}*$decomp{NTHRDS_CPL}< 2048){
	print "WARNING: Forcing intrepid test to use at least 512 nodes\n";
	$decomp{NTASKS_CPL}=512; $decomp{NTHRDS_CPL}=4;
    }


# Provides a method to limit the maximum number of threads through use of an environment variable.

    if(defined $ENV{CESM_MAX_THREADS}){
	my $maxthrds = $ENV{CESM_MAX_THREADS};
	my $comp;
	foreach $comp (qw(NTHRDS_ATM NTHRDS_LND NTHRDS_OCN NTHRDS_ICE NTHRDS_GLC NTHRDS_CPL)){
          $decomp{$comp} = ( $decomp{$comp} < $maxthrds ) ? $decomp{$comp}:$maxthrds;
        }
    }
    

    $cfg_ref->set('NTASKS_ATM', $decomp{'NTASKS_ATM'});
    $cfg_ref->set('NTASKS_LND', $decomp{'NTASKS_LND'});
    $cfg_ref->set('NTASKS_ICE', $decomp{'NTASKS_ICE'});
    $cfg_ref->set('NTASKS_OCN', $decomp{'NTASKS_OCN'});
    $cfg_ref->set('NTASKS_CPL', $decomp{'NTASKS_CPL'});
    $cfg_ref->set('NTASKS_GLC', $decomp{'NTASKS_GLC'});
    
    $cfg_ref->set('NTHRDS_ATM', $decomp{'NTHRDS_ATM'});
    $cfg_ref->set('NTHRDS_LND', $decomp{'NTHRDS_LND'});
    $cfg_ref->set('NTHRDS_ICE', $decomp{'NTHRDS_ICE'});
    $cfg_ref->set('NTHRDS_OCN', $decomp{'NTHRDS_OCN'});
    $cfg_ref->set('NTHRDS_CPL', $decomp{'NTHRDS_CPL'});
    $cfg_ref->set('NTHRDS_GLC', $decomp{'NTHRDS_GLC'});

    $cfg_ref->set('ROOTPE_ATM', $decomp{'ROOTPE_ATM'});
    $cfg_ref->set('ROOTPE_LND', $decomp{'ROOTPE_LND'});
    $cfg_ref->set('ROOTPE_ICE', $decomp{'ROOTPE_ICE'});
    $cfg_ref->set('ROOTPE_OCN', $decomp{'ROOTPE_OCN'});
    $cfg_ref->set('ROOTPE_CPL', $decomp{'ROOTPE_CPL'});
    $cfg_ref->set('ROOTPE_GLC', $decomp{'ROOTPE_GLC'});

# tcraig, assume NINST is not set in config_pes.xml so it can be set by _N, but a pes_file could override above
#    $cfg_ref->set('NINST_ATM', $decomp{'NINST_ATM'});
#    $cfg_ref->set('NINST_LND', $decomp{'NINST_LND'});
#    $cfg_ref->set('NINST_ICE', $decomp{'NINST_ICE'});
#    $cfg_ref->set('NINST_OCN', $decomp{'NINST_OCN'});
#    $cfg_ref->set('NINST_GLC', $decomp{'NINST_GLC'});    
    
    $cfg_ref->set('PIO_NUMTASKS',     $decomp{'PIO_NUMTASKS'});
    $cfg_ref->set('PIO_STRIDE',       $decomp{'PIO_STRIDE'});
    $cfg_ref->set('PIO_TYPENAME',     $decomp{'PIO_TYPENAME'});
    $cfg_ref->set('PIO_ROOT',         $decomp{'PIO_ROOT'});
    $cfg_ref->set('PIO_DEBUG_LEVEL',  $decomp{'PIO_DEBUG_LEVEL'});
    
    $cfg_ref->set('ATM_PIO_NUMTASKS', $decomp{'ATM_PIO_NUMTASKS'});
    $cfg_ref->set('ATM_PIO_STRIDE',   $decomp{'ATM_PIO_STRIDE'});
    $cfg_ref->set('ATM_PIO_TYPENAME', $decomp{'ATM_PIO_TYPENAME'});
    $cfg_ref->set('ATM_PIO_ROOT',     $decomp{'ATM_PIO_ROOT'});

    $cfg_ref->set('LND_PIO_NUMTASKS', $decomp{'LND_PIO_NUMTASKS'});
    $cfg_ref->set('LND_PIO_STRIDE',   $decomp{'LND_PIO_STRIDE'});
    $cfg_ref->set('LND_PIO_TYPENAME', $decomp{'LND_PIO_TYPENAME'});
    $cfg_ref->set('LND_PIO_ROOT',     $decomp{'LND_PIO_ROOT'});
    
    $cfg_ref->set('OCN_PIO_NUMTASKS', $decomp{'OCN_PIO_NUMTASKS'});
    $cfg_ref->set('OCN_PIO_STRIDE',   $decomp{'OCN_PIO_STRIDE'});
    $cfg_ref->set('OCN_PIO_TYPENAME', $decomp{'OCN_PIO_TYPENAME'});
    $cfg_ref->set('OCN_PIO_ROOT',     $decomp{'OCN_PIO_ROOT'});
    
    $cfg_ref->set('ICE_PIO_NUMTASKS', $decomp{'ICE_PIO_NUMTASKS'});
    $cfg_ref->set('ICE_PIO_STRIDE',   $decomp{'ICE_PIO_STRIDE'});
    $cfg_ref->set('ICE_PIO_TYPENAME', $decomp{'ICE_PIO_TYPENAME'});
    $cfg_ref->set('ICE_PIO_ROOT',     $decomp{'ICE_PIO_ROOT'});
    
    $cfg_ref->set('CPL_PIO_NUMTASKS', $decomp{'CPL_PIO_NUMTASKS'});
    $cfg_ref->set('CPL_PIO_STRIDE',   $decomp{'CPL_PIO_STRIDE'});
    $cfg_ref->set('CPL_PIO_TYPENAME', $decomp{'CPL_PIO_TYPENAME'});
    $cfg_ref->set('CPL_PIO_ROOT',     $decomp{'CPL_PIO_ROOT'});
    
    $cfg_ref->set('GLC_PIO_NUMTASKS', $decomp{'GLC_PIO_NUMTASKS'});
    $cfg_ref->set('GLC_PIO_STRIDE',   $decomp{'GLC_PIO_STRIDE'});
    $cfg_ref->set('GLC_PIO_TYPENAME', $decomp{'GLC_PIO_TYPENAME'});
    $cfg_ref->set('GLC_PIO_ROOT',     $decomp{'GLC_PIO_ROOT'});
    
    $cfg_ref->set('PES_LEVEL' , $decomp{'PES_LEVEL'});
}


# resolve the dollar referenced values for the pe stuff
# allow up to 4 depths then stop
# so, check the var value, if it starts with dollar, remove
#     the dollar and check the next value.  continue until a
#     non dollar value is found up to max depths.

my @xvars = qw(NTASKS_ATM NTHRDS_ATM ROOTPE_ATM NINST_ATM
	       NTASKS_LND NTHRDS_LND ROOTPE_LND NINST_LND
	       NTASKS_ICE NTHRDS_ICE ROOTPE_ICE NINST_ICE
	       NTASKS_OCN NTHRDS_OCN ROOTPE_OCN NINST_OCN
	       NTASKS_GLC NTHRDS_GLC ROOTPE_GLC NINST_GLC
	       NTASKS_CPL NTHRDS_CPL ROOTPE_CPL
               ATM_PIO_NUMTASKS ATM_PIO_STRIDE ATM_PIO_TYPENAME ATM_PIO_ROOT
               LND_PIO_NUMTASKS LND_PIO_STRIDE LND_PIO_TYPENAME LND_PIO_ROOT
               ICE_PIO_NUMTASKS ICE_PIO_STRIDE ICE_PIO_TYPENAME ICE_PIO_ROOT
               OCN_PIO_NUMTASKS OCN_PIO_STRIDE OCN_PIO_TYPENAME OCN_PIO_ROOT
               CPL_PIO_NUMTASKS CPL_PIO_STRIDE CPL_PIO_TYPENAME CPL_PIO_ROOT
               GLC_PIO_NUMTASKS GLC_PIO_STRIDE GLC_PIO_TYPENAME GLC_PIO_ROOT);
my $xvarf;
my $xvar1;
my $xvar2;
my $xvar3;
my $xvar4;
foreach my $xvar ( @xvars ) {
    $xvar1 = $cfg_ref->get("$xvar");
    $xvar2 = "";
    $xvar3 = "";
    $xvar4 = "";
    $xvarf = $xvar1;
    if ($xvarf =~ m/^\$.+$/) {
	$xvar2 = $xvarf;
        $xvar2 =~ s/^\$(.+$)/$1/ ;
        $xvar2 = $cfg_ref->get("$xvar2");
	$xvarf = $xvar2;
        if ($xvarf =~ m/^\$.+$/) {
   	   $xvar3 = $xvarf;
           $xvar3 =~ s/^\$(.+$)/$1/ ;
           $xvar3 = $cfg_ref->get("$xvar3");
	   $xvarf = $xvar3;
           if ($xvarf =~ m/^\$.+$/) {
      	      $xvar4 = $xvarf;
              $xvar4 =~ s/^\$(.+$)/$1/ ;
              $xvar4 = $cfg_ref->get("$xvar4");
	      $xvarf = $xvar4;
              if ($xvar4 =~ m/^\$.+$/) {
		  die "xvar recursive search failed $xvar $xvar1 $xvar2 $xvar3 $xvar4 \n";
              }
           }
        }
    }
#    print "xvar found $xvar $xvar1 $xvar2 $xvar3 $xvar4 \n";
    $cfg_ref->set("$xvar", "$xvarf");
}

#-----------------------------------------------------------------------------------------------
# Set env_run variables 
$cfg_ref->set('CCSMUSER', "$ENV{'LOGNAME'}");
$cfg_ref->set('CASEROOT', "$caseroot");
$cfg_ref->set('CASE'    , "$case");
$cfg_ref->set('CCSMROOT', "$ccsmroot");
$cfg_ref->set('XMLMODE' , "$xmlmode");

my $repotag;
if (-f "$ccsmroot/ChangeLog") { 
    $repotag =`cat $ccsmroot/ChangeLog | grep 'Tag name:' | head -1`;
} else {
    $repotag =`cat $ccsmroot/models/atm/cam/doc/ChangeLog | grep 'Tag name:' | head -1`;
}
my @repotag = split(/ /,$repotag); 
$repotag = $repotag[2]; 
chomp($repotag);
$cfg_ref->set('CCSM_REPOTAG', $repotag);

#-----------------------------------------------------------------------------------------------
# Create the case directory tree
my $sysmod;
my $scriptsroot = "$ccsmroot/scripts";

print "Creating $caseroot $eol $eol";

# Create relevant directories
my @mkdirs = qw(. README Tools SourceMods LockedFiles Tools/XML/Lite Tools/Templates);
foreach my $mkdir ( @mkdirs ) {
    $sysmod = "mkdir -p $caseroot/$mkdir"; 
    system ($sysmod); if ($? == -1) {print "$sysmod failed: $!\n";}
}

# Create a README.case
my $file = "$caseroot/README.case";
my $fh = IO::File->new($file, '>' ) or die "can't open file: $file\n";
print $fh "$commandline\n";

# Copy relevant files into the case directory
my @files = qw(configure check_input_data  archive_metadata.sh 
	       create_production_test xmlchange check_case); 
foreach my $file (@files) {
    $sysmod = "cp -p $scriptsroot/ccsm_utils/Tools/$file $caseroot"; 
    system($sysmod); if ($? == -1) {print "$sysmod failed: $!\n";}
}
$sysmod = "chmod u+w $caseroot/create_production_test";
system($sysmod); if ($? == -1) {print "$sysmod failed: $!\n";}

# Copy relevant files into the case Tools/ directory
@files = qw(ccsm_getenv ccsm_check_lockedfiles ccsm_buildexe.csh ccsm_buildnml.csh
            ccsm_prestage.csh ccsm_postrun.csh clean_build listfilesin_streams
	    ccsm_sedfile generate_batch.csh generate_resolved.csh taskmaker.pl
	    xml2env ccsm_l_archive.csh st_archive.sh lt_archive.csh lt_archive.pl );
foreach my $file (@files) {
    $sysmod = "cp -p $scriptsroot/ccsm_utils/Tools/$file $caseroot/Tools"; 
    system($sysmod); if ($? == -1) {print "$sysmod failed: $!\n";}
}

# Copy relevant files into the case Tools/ directory
@files = qw(getTiming.csh getTiming.pl perf_summary.pl);
foreach my $file (@files) {
    $sysmod = "cp -p $scriptsroot/ccsm_utils/Tools/timing/$file $caseroot/Tools"; 
    system($sysmod); if ($? == -1) {print "$sysmod failed: $!\n";}
}

@files = qw(config_definition.xml config_grid.xml ConfigCase.pm);
foreach my $file (@files) {
    $sysmod = "cp -p $scriptsroot/ccsm_utils/Case.template/$file $caseroot/Tools"; 
    system($sysmod); if ($? == -1) {print "$sysmod failed: $!\n";}
}

@files = qw(Makefile mkSrcfiles mkDepends);
foreach my $file (@files) {
    $sysmod = "cp -p $scriptsroot/ccsm_utils/Build/$file $caseroot/Tools"; 
    system($sysmod); if ($? == -1) {print "$sysmod failed: $!\n";}
}

# Copy relevant files into the case Tools/XML directory
$sysmod = "cp -p $scriptsroot/ccsm_utils/Tools/perl5lib/XML/Lite.pm $caseroot/Tools/XML"; 
system($sysmod); if ($? == -1) {print "$sysmod failed: $!\n";}
$sysmod = "cp -p $scriptsroot/ccsm_utils/Tools/perl5lib/XML/Lite/Element.pm $caseroot/Tools/XML/Lite"; 
system($sysmod); if ($? == -1) {print "$sysmod failed: $!\n";}

# Create the relevant template files in the caseroot Tools directory
my @comps  = qw(cam datm xatm xatm satm clm dlnd xlnd slnd cice dice xice sice pop2 docn xocn socn camdom sglc xglc cism);
my @models = qw(COMP_ATM COMP_LND COMP_ICE COMP_OCN COMP_GLC);

my %templates = (
		 cam     => "models/atm/cam/bld/cam.cpl7.template",
		 clm     => "models/lnd/clm/bld/clm.cpl7.template",
		 cice    => "models/ice/cice/bld/cice.cpl7.template",
		 pop2    => "models/ocn/pop2/bld/pop2.cpl7.template",
		 cism    => "models/glc/cism/bld/cism.cpl7.template",
		 datm    => "models/atm/datm/bld/datm.cpl7.template",
		 dlnd    => "models/lnd/dlnd/bld/dlnd.cpl7.template",
		 dice    => "models/ice/dice/bld/dice.cpl7.template",
		 docn    => "models/ocn/docn/bld/docn.cpl7.template",
		 xatm    => "models/atm/xatm/bld/xatm.template",
		 xlnd    => "models/lnd/xlnd/bld/xlnd.template",
		 xice    => "models/ice/xice/bld/xice.template",
		 xocn    => "models/ocn/xocn/bld/xocn.template",
		 xglc    => "models/glc/xglc/bld/xglc.template",
		 satm    => "models/atm/satm/bld/satm.template",
		 slnd    => "models/lnd/slnd/bld/slnd.template",
		 sice    => "models/ice/sice/bld/sice.template",
		 socn    => "models/ocn/socn/bld/socn.template",
		 sglc    => "models/glc/sglc/bld/sglc.template",
		 camdom  => "models/atm/cam/bld/camdom.cpl7.template"
		 );

foreach my $comp (@comps)  {
    foreach my $model (@models) {
	if ($cfg_ref->get($model) eq $comp) {
	    my $file = $templates{"$comp"};
	    $sysmod = "cp -p $ccsmroot/$file $caseroot/Tools/Templates/.";
	    system($sysmod); if ($? == -1) {print "$sysmod failed: $!\n"; exit}
	}
    }
}
$sysmod = "cp -p $ccsmroot/models/drv/bld/cpl.template $caseroot/Tools/Templates/.";
system($sysmod); if ($? == -1) {print "$sysmod failed: $!\n"; exit}
$sysmod = "cp -p $ccsmroot/models/drv/bld/ccsm.template $caseroot/Tools/Templates/.";
system($sysmod); if ($? == -1) {print "$sysmod failed: $!\n"; exit}
$sysmod = "chmod +x $caseroot/Tools/Templates/*template"; 
system($sysmod); if ($? == -1) {print "$sysmod failed: $!\n"; exit}

# Copy relevant xml files to the caseroot Tools directory
foreach my $comp (@comps)  {
    foreach my $model (@models) {
	if ($cfg_ref->get($model) eq $comp) {
	    my $component = $cfg_ref->get($model); 
	    if ($component eq 'pop2') {
		$sysmod = "cp $ccsmroot/models/ocn/pop2/bld/generate_pop_decomp.pl  $caseroot/Tools/Templates/"; 
		system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
		$sysmod = "cp $ccsmroot/models/ocn/pop2/bld/pop_decomp.xml $caseroot/Tools/Templates"; 
		system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
	    } 
	    if ($component eq 'cice') {
		$sysmod = "cp $ccsmroot/models/ice/cice/bld/generate_cice_decomp.pl $caseroot/Tools/Templates/"; 
		system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
		$sysmod = "cp $ccsmroot/models/ice/cice/bld/cice_decomp.xml $caseroot/Tools/Templates"; 
		system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
	    }
	    if ($component eq 'datm') {
		$sysmod = "cp $ccsmroot/models/atm/datm/bld/datm.template.streams.xml $caseroot/Tools/Templates/"; 
		system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
	    }	    
	    if ($component eq 'dlnd') {
		$sysmod = "cp $ccsmroot/models/lnd/dlnd/bld/dlnd.template.streams.xml $caseroot/Tools/Templates/"; 
		system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
	    }
	    if ($component eq 'dice') {
		$sysmod = "cp $ccsmroot/models/ice/dice/bld/dice.template.streams.xml $caseroot/Tools/Templates/"; 
		system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
	    }
	    if ($component eq 'docn') {
		$sysmod = "cp $ccsmroot/models/ocn/docn/bld/docn.template.streams.xml $caseroot/Tools/Templates/"; 
		system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
	    }
	}
    }
}

# Create the relevant caseroot Sourcemods directories
my $moddir = "$caseroot/SourceMods";
foreach my $comp (@comps)  {
    foreach my $model (@models) {
	if ($cfg_ref->get($model) eq $comp) {
	    $sysmod = "mkdir -p $moddir/src.$comp"; 
	    system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
	}
    }
}
$sysmod = "mkdir -p $caseroot/SourceMods/src.share"; 
system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
$sysmod = "mkdir -p $caseroot/SourceMods/src.drv"  ; 
system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
$sysmod = "chmod -R u+w $caseroot/SourceMods"; 
system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}

# Create machine specific Macros file
$sysmod = "cat $machdir/Macros.cppdefs > $caseroot/Macros.$mach";
system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
$sysmod = "cat $machdir/Macros.$mach >> $caseroot/Macros.$mach";
system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
$sysmod = "cat $machdir/Macros.postdefs >> $caseroot/Macros.$mach";
system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}

# The following creates env_mach_specific
$sysmod = "cp $machdir/env_machopts.$mach $caseroot/env_mach_specific";
system($sysmod);
if ($? == -1) {die "$sysmod failed: $!\n";}

# Write the xml files
$cfg_ref->write_file("$caseroot/env_case.xml"    , "xml");
$cfg_ref->write_file("$caseroot/env_build.xml"   , "xml");
$cfg_ref->write_file("$caseroot/env_conf.xml"    , "xml");
$cfg_ref->write_file("$caseroot/env_run.xml"     , "xml");
$cfg_ref->write_file("$caseroot/env_mach_pes.xml", "xml");  

# Copy env_case.xml in to locked files
$sysmod = "cp $caseroot/env_case.xml $caseroot/LockedFiles/env_case.xml.locked"; 
system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
print "Locking file $caseroot/env_case.xml \n";

$cfg_ref->write_doc("$caseroot/README/readme_env");

$sysmod = "cp $scriptsroot/README $caseroot/README/readme_general"; 
system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}

$sysmod = "cp $scriptsroot/ccsm_utils/Tools/create_production_test_readme $caseroot/README/readme_create_production_test"; 
system($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}

my $file = "$caseroot/CaseStatus";
my $fh = IO::File->new($file, '>' ) or die "can't open file: $file\n";
my $time = time;
my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
$year = 1900+$year;
$mon = 1+$mon;
print $fh "$commandline\n";
printf ($fh "case created %04u-%02u-%02u %02u:%02u:%02u\n",$year,$mon,$mday,$hour,$min,$sec);

print "Successfully created the case for $mach \n";

if ($print>=2) { print "create_xml done.$eol"; }
exit;

#-----------------------------------------------------------------------------------------------
# FINNISHED ####################################################################################
#-----------------------------------------------------------------------------------------------

sub absolute_path {
#
# Convert a pathname into an absolute pathname, expanding any . or .. characters.
# Assumes pathnames refer to a local filesystem.
# Assumes the directory separator is "/".
#
  my $path = shift;
  my $cwd = getcwd();  # current working directory
  my $abspath;         # resulting absolute pathname

# Strip off any leading or trailing whitespace.  (This pattern won't match if
# there's embedded whitespace.
  $path =~ s!^\s*(\S*)\s*$!$1!;

# Convert relative to absolute path.

  if ($path =~ m!^\.$!) {          # path is "."
      return $cwd;
  } elsif ($path =~ m!^\./!) {     # path starts with "./"
      $path =~ s!^\.!$cwd!;
  } elsif ($path =~ m!^\.\.$!) {   # path is ".."
      $path = "$cwd/..";
  } elsif ($path =~ m!^\.\./!) {   # path starts with "../"
      $path = "$cwd/$path";
  } elsif ($path =~ m!^[^/]!) {    # path starts with non-slash character
      $path = "$cwd/$path";
  }

  my ($dir, @dirs2);
  my @dirs = split "/", $path, -1;   # The -1 prevents split from stripping trailing nulls
                                     # This enables correct processing of the input "/".

  # Remove any "" that are not leading.
  for (my $i=0; $i<=$#dirs; ++$i) {
      if ($i == 0 or $dirs[$i] ne "") {
	  push @dirs2, $dirs[$i];
      }
  }
  @dirs = ();

  # Remove any "."
  foreach $dir (@dirs2) {
      unless ($dir eq ".") {
	  push @dirs, $dir;
      }
  }
  @dirs2 = ();

  # Remove the "subdir/.." parts.
  foreach $dir (@dirs) {
    if ( $dir !~ /^\.\.$/ ) {
        push @dirs2, $dir;
    } else {
        pop @dirs2;   # remove previous dir when current dir is ..
    }
  }
  if ($#dirs2 == 0 and $dirs2[0] eq "") { return "/"; }
  $abspath = join '/', @dirs2;
  return( $abspath );
}

#-------------------------------------------------------------------------------

sub subst_env_path {
#
# Substitute for any environment variables contained in a pathname.
# Assumes the directory separator is "/".
#
  my $path = shift;
  my $newpath;         # resulting pathname

# Strip off any leading or trailing whitespace.  (This pattern won't match if
# there's embedded whitespace.
  $path =~ s!^\s*(\S*)\s*$!$1!;

  my ($dir, @dirs2);
  my @dirs = split "/", $path, -1;   # The -1 prevents split from stripping trailing nulls
                                     # This enables correct processing of the input "/".

  foreach $dir (@dirs) {
    if ( $dir =~ /^\$(.+)$/ ) {
        push @dirs2, $ENV{$1};
    } else {
        push @dirs2, $dir;
    }
  }
  $newpath = join '/', @dirs2;
  return( $newpath );
}

#-------------------------------------------------------------------------------

sub get_option {

    my ($mes, @expect) = @_;
    my ($ans, $expect, $max_tries);

    $max_tries = 5;
    print $mes;
    while ($max_tries) {
	$ans = <>; chomp $ans;
	--$max_tries;
	$ans =~ s/^\s+//;
	$ans =~ s/\s+$//;
	# Check for null response which indicates that default is accepted.
	unless ($ans) { return ""; }
	foreach $expect (@expect) {
	    if ($ans =~ /^$expect$/i) { return $expect; }
	}
	if ($max_tries > 1) {
	    print "$ans does not match any of the expected values: @expect\n";
	    print "Please try again: ";
	} elsif ($max_tries == 1) {
	    print "$ans does not match any of the expected values: @expect\n";
	    print "Last chance! ";
	}
    }
    die "Failed to get answer to question: $mes\n";
}

#-------------------------------------------------------------------------------

sub print_hash {
    my %h = @_;
    my ($k, $v);
    while ( ($k,$v) = each %h ) { print "$k => $v\n"; }
}

#-------------------------------------------------------------------------------

sub set_grid
{
    # Set the parameters for the specified horizontal grid.  The
    # parameters are read from an input file, and if no grid matches are
    # found then issue error message.
    # This routine uses the configuration defined at the package level ($cfg_ref).

    my ($grid_file, $grid, $cfg_ref) = @_;
    my $xml = XML::Lite->new( $grid_file );
    my $root = $xml->root_element();

    # Check for valid root node
    my $name = $root->get_name();
    $name eq "config_horiz_grid" or die
	"file $grid_file is not a horizontal grid parameters file\n";

    # Read the grid parameters from $grid_file.
    my @e = $xml->elements_by_name( "horiz_grid" );
    my %a = ();

    # Search for matching grid.
    my $found = 0;
  HGRID:
    while ( my $e = shift @e ) {
	%a = $e->get_attributes();
	if ( ! defined($a{'GRID'}     ) ) { next; }
	if ( ! defined($a{'SHORTNAME'}) ) { next; }
	if ( ($grid eq $a{'GRID'}) || ($grid eq $a{'SHORTNAME'})) {
	    $found = 1;
	    last HGRID;
	}
    }

    # Die unless search was successful.
    unless ($found) { 
	print "set_grid: no match for grid $grid - possible grid values are \n";
	my @e_err = $xml->elements_by_name( "horiz_grid" );
	my %a_err = ();
	while ( my $e_err = shift @e_err ) {
	    %a_err = $e_err->get_attributes();
	    if (defined($a_err{'SHORTNAME'})) { 
		print " $a_err{'GRID'} (SHORTNAME: $a_err{'SHORTNAME'}) \n";
	    }
	}
	die "set_grid: exiting\n"; 
    }
    my $shortname = $a{'SHORTNAME'};
    my $longname  = $a{'GRID'};

    my @ids = keys %$cfg_ref;
    foreach my $id (sort @ids) {
	foreach my $attr (keys %a) {
	    if ( ! $cfg_ref->is_ignore_name($attr) and ! $cfg_ref->is_valid_name($attr) ) { 
                die "set_grid: invalid id $attr in grid $grid in file $grid_file exiting\n"; 
	    }
	    if ($attr eq $id) {
		my $value = $a{$attr};
		$cfg_ref->set($id, $value);
	    }
	}
    }

    # Search for matching grid for each component

    my $atm_grid = $a{'ATM_GRID'};
    my $lnd_grid = $a{'LND_GRID'};
    my $ice_grid = $a{'ICE_GRID'};
    my $ocn_grid = $a{'OCN_GRID'};

    @e = $xml->elements_by_name( "horiz_grid" );
    %a = ();
    $found = 0;
  HGRID:
    while ( my $e = shift @e ) {
	%a = $e->get_attributes();
	if ( $atm_grid eq $a{'GLOB_GRID'} ) {
	    $found = 1;
	    last HGRID;
	}
    }
    if ($found) {
	$cfg_ref->set('ATM_NX', $a{'nx'});
	$cfg_ref->set('ATM_NY', $a{'ny'});
    }
    @e = $xml->elements_by_name( "horiz_grid" );
    %a = ();
    $found = 0;
  HGRID:
    while ( my $e = shift @e ) {
	%a = $e->get_attributes();
	if ( $lnd_grid eq $a{'GLOB_GRID'} ) {
	    $found = 1;
	    last HGRID;
	}
    }
    if ($found) {
	$cfg_ref->set('LND_NX', $a{'nx'});
	$cfg_ref->set('LND_NY', $a{'ny'});
    }
    @e = $xml->elements_by_name( "horiz_grid" );
    %a = ();
    $found = 0;
  HGRID:
    while ( my $e = shift @e ) {
	%a = $e->get_attributes();
	if ( $ice_grid eq $a{'GLOB_GRID'} ) {
	    $found = 1;
	    last HGRID;
	}
    }
    if ($found) {
	$cfg_ref->set('ICE_NX', $a{'nx'});
	$cfg_ref->set('ICE_NY', $a{'ny'});
    }

    @e = $xml->elements_by_name( "horiz_grid" );
    %a = ();
    $found = 0;
  HGRID:
    while ( my $e = shift @e ) {
	%a = $e->get_attributes();
	if ( $lnd_grid eq $a{'GLOB_GRID'} ) {
	    $found = 1;
	    last HGRID;
	}
    }
    if ($found) {
	$cfg_ref->set('GLC_NX', $a{'nx'});
	$cfg_ref->set('GLC_NY', $a{'ny'});
    }
    @e = $xml->elements_by_name( "horiz_grid" );
    %a = ();
    $found = 0;
  HGRID:
    while ( my $e = shift @e ) {
	%a = $e->get_attributes();
	if ( $ocn_grid eq $a{'GLOB_GRID'} ) {
	    $found = 1;
	    last HGRID;
	}
    }
    if ($found) {
	$cfg_ref->set('OCN_NX', $a{'nx'});
	$cfg_ref->set('OCN_NY', $a{'ny'});
    }
    return ($longname, $shortname); 
 }

#-------------------------------------------------------------------------------

sub set_compset
{
    # Set the parameters for the specified compset.  The
    # parameters are read from an input file, and if no compset matches are
    # found then issue error message.
    # This routine uses the configuration defined at the package level ($cfg_ref).

    my ($compset_file, $compset, $grid_longname, $grid_shortname, $cfg_ref, $caseroot) = @_;

    my $file = "$caseroot/README.xml";
    my $fh = IO::File->new($file, '>' ) or die "can't open file: $file\n";

    my $xml = XML::Lite->new( $compset_file );
    my $root = $xml->root_element();
    my $name = $root->get_name();
    $name eq "config_compset" or die
	"file $compset_file is not a compset parameters file\n";

    # Read the compset parameters from $compset_file.
    my @e = $xml->elements_by_name( "compset" );

    my $comment; 
    my $desc;
    my $compset_longname; 
    my $compset_shortname; 
    my $temp; 
    my $found;
    my $valid_grid = 0;

    # ========================================================
    # 0. Match on name (exactly)
    # ========================================================
    my @e = $xml->elements_by_name( "compset" );
    my %a = ();

    $found = 0;
  NAME:
    while ( my $e = shift @e ) {
	%a = $e->get_attributes();
	if ( ($compset eq $a{'NAME'}) || ($compset eq $a{'SHORTNAME'})) {
	    $found = 1;
	    $compset_longname  = $a{'NAME'};
	    $compset_shortname = $a{'SHORTNAME'};
	    print     "(COMPSET)  $compset_longname \n";
	    print $fh "(COMPSET)  $compset_longname \n";
	    $temp = $a{'NAME'}." (".$a{'SHORTNAME'}.")"; $cfg_ref->set('CCSM_COMPSET' , "$temp");
	    $temp = $a{'NAME'}                         ; $cfg_ref->set('CCSM_LCOMPSET', "$temp");
	    $temp = $a{'SHORTNAME'}                    ; $cfg_ref->set('CCSM_SCOMPSET', "$temp");
	    if ($a{'DESC'}) {
		$desc = $a{'DESC'};
	    }
	    last NAME;
	}
    }
    unless ($found) { 
	print "set_compset: no match for compset $compset - possible compset values are \n";
	print_compsets($compset_file);
	die "set_compset: exiting\n"; 
    }

    # ========================================================
    # 1. Match on default compset settings 
    # ========================================================
    @e = $xml->elements_by_name( "compset" );
    while ( my $e = shift @e ) {
	%a = $e->get_attributes();
	if ($a{'BEG_COMPSET_MATCH'}) {
	    if ($compset_longname =~ /^$a{'BEG_COMPSET_MATCH'}/)  {
		my @ids = keys %$cfg_ref;
		foreach my $id (sort @ids) {
		    foreach my $attr (keys %a) {
			if ( ! $cfg_ref->is_ignore_name($attr) and ! $cfg_ref->is_valid_name($attr) ) { 
			    die "set_compset: invalid id $attr in compset $compset in file $compset_file exiting\n"; 
			}
			if ($attr eq $id) {
			    my $value = $a{$attr};
			    print     "(default)  $attr: $value \n";
			    print $fh "(default)  $attr: $value \n";
			    $cfg_ref->set($id, $value);
			}
		    }
		}
	    }
	}
    }

    # ========================================================
    # 2. Match on general compset settings
    # ========================================================
    @e = $xml->elements_by_name( "compset" );
    while ( my $e = shift @e ) {
	%a = $e->get_attributes();
	if ($a{'GEN_COMPSET_MATCH'}) {
	    if ($compset_longname =~ /$a{'GEN_COMPSET_MATCH'}/)  {
		my $first_time = 1;
		my @ids = keys %$cfg_ref;
		foreach my $id (sort @ids) {
		    foreach my $attr (keys %a) {
			if ( ! $cfg_ref->is_ignore_name($attr) and ! $cfg_ref->is_valid_name($attr) ) { 
			    die "set_compset: invalid id $attr in compset $compset in file $compset_file exiting\n"; 
			}
			if ($attr eq $id) {
			    my $attrib = $a{$attr};
			    my $curval = $cfg_ref->get($id);
			    # Append new value on the end of old - unless a string matches - then replace it
			    my $newval = $attrib;
			    if (($attr =~ m/\s*_CONFIG_OPTS/) || ($attr =~ m/\s*_NAMELIST_OPTS/)) {
				if  ($curval !~ m/^\s*$/)  { 
				    my @attrib = split(' ', $attrib);
				    if ($curval =~ m/$attrib[0]/) {
					$curval =~ s/$attrib[0]\s+\w+/$attrib/;
					$newval =  $curval;
				    } else {
					$newval = "$curval $attrib";
				    }
				}
			    }
			    print     "(compset)  $attr: $newval \n";
			    print $fh "(compset)  $attr: $newval \n";
			    $cfg_ref->set($id, $newval);
			}
		    }
		}
		if ($a{'VALID_GRID_MATCH'}) {
		    my $match = $a{'VALID_GRID_MATCH'};
		    if (($grid_longname =~ /$match/) || ($grid_shortname =~ /$match/)) {
			# do nothing
		    } else {
			$match =~ s/\|/ or /g;
			print "\n *** ERROR: invalid grid for this compset *** \n ";
			print "    supported grids for this compset must match \n ";
			print "          $match \n"; 
			die "     please retry this compset at one of the supported resolutions \n \n";
		    }
		}		
	    }
	}
    }

    # ========================================================
    # 3. Match on compset AND grid
    # ========================================================
    @e = $xml->elements_by_name( "compset" );
    $found = 0;
  COMPGRID_MATCH:
    while ( my $e = shift @e ) {
	%a = $e->get_attributes();
	if (($a{'GRID_MATCH'} && $a{'RES_COMPSET_MATCH'}) || 
	    ($a{'GRID_MATCH'} && $a{'SSTICE_COMPSET_MATCH'})) {
	    my $compset_match = 0;
	    my $grid_match = 0;
	    if ($a{'RES_COMPSET_MATCH'}) {
		if ($compset_longname eq $a{'RES_COMPSET_MATCH'})  {
		    $compset_match = 1;
		}
	    }
	    if ($a{'SSTICE_COMPSET_MATCH'}) {
		if ($compset_longname =~ /^$a{'SSTICE_COMPSET_MATCH'}/)  {
		    $compset_match = 1;
		}
	    }
	    if ($grid_longname =~ /$a{'GRID_MATCH'}/ || $grid_shortname =~ /$a{'GRID_MATCH'}/ ) {
		$grid_match = 1;
		$valid_grid = 1;
	    }
	    if ($grid_match && $compset_match) {
		my @ids = keys %$cfg_ref;
		foreach my $id (sort @ids) {
		    foreach my $attr (keys %a) {
			if ( ! $cfg_ref->is_ignore_name($attr) and ! $cfg_ref->is_valid_name($attr) ) { 
			    die "set_compset: invalid id $attr in compset $compset in file $compset_file exiting\n"; 
			}
			if ($attr eq $id) {
			    my $value = $a{$attr};
			    print     "(gridset)  $attr: $value \n";
			    print $fh "(gridset)  $attr: $value \n";
			    $cfg_ref->set($id, $value);
			}
		    }
		}
	    }
	}
    }

    # ========================================================
    # 3. Match on name exactly
    # ========================================================
    @e = $xml->elements_by_name( "compset" );
  NAME:
    while ( my $e = shift @e ) {
	%a = $e->get_attributes();
	if ($compset_longname eq $a{'NAME'}) {
	    my @ids = keys %$cfg_ref;
	    foreach my $id (sort @ids) {
		foreach my $attr (keys %a) {
		    if ( ! $cfg_ref->is_ignore_name($attr) and ! $cfg_ref->is_valid_name($attr) ) { 
			die "set_compset: invalid id $attr in compset $compset in file $compset_file exiting\n"; 
		    }
		    if ($attr eq $id) {
			my $value = $a{$attr};
			print     "(name   )  $attr: $value \n";
			print $fh "(name   )  $attr: $value \n";
			$cfg_ref->set($id, $value);
		    }
		}
	    }
	    last NAME;
	}
    }

    print     "***********************************************************\n";
    print     "Component set     : $compset_longname ($compset_shortname) \n";
    print     "Desc              : $desc \n";
    print     "***********************************************************\n\n";
    print $fh "***********************************************************\n";
    print $fh "Component set     : $compset_longname ($compset_shortname) \n";
    print $fh "Desc              : $desc \n";
    print $fh "***********************************************************\n\n";


    
    # Print config_ref values
    my @ids = keys %$cfg_ref;
    foreach my $id (sort @ids) {
	my $value = $cfg_ref->get($id);
	# print     " $id: $value \n";
	print $fh " <entry id=\"$id\" value=\"$value\" /> \n";
    }
    return ($compset_longname, $compset_shortname); 
}

#-------------------------------------------------------------------------------

sub check_grid
{
    # Set the parameters for the specified horizontal grid.  The
    # parameters are read from an input file, and if no grid matches are
    # found then issue error message.
    # This routine uses the configuration defined at the package level ($cfg_ref).

    my ($grid_file, $grid, $compset_longname) = @_;
    my $xml = XML::Lite->new( $grid_file );
    my $root = $xml->root_element();

    # Check for valid root node
    my $name = $root->get_name();
    $name eq "config_horiz_grid" or die
	"file $grid_file is not a horizontal grid parameters file\n";

    # Read the grid parameters from $grid_file.
    my @e = $xml->elements_by_name( "horiz_grid" );
    my %a = ();

    # Search for matching grid.
  HGRID:
    while ( my $e = shift @e ) {
	%a = $e->get_attributes();
	if ($grid eq $a{'GRID'} || $grid eq $a{'SHORTNAME'}) {
	    if (defined $a{'VALID_COMPSET_MATCH'}) {
		if ($compset_longname =~ /^$a{'VALID_COMPSET_MATCH'}/)  {
		    # do nothing
		} else {
		    die <<"EOF";
*** Invalid compset - $compset - for grid - $grid - only valid compset must match $a{'VALID_COMPSET_MATCH'} ***
*** Invoke create_newcase again with a vaid compset for this grid ***
EOF
                }
		last HGRID; 
	    }
	}
    }
}

#-------------------------------------------------------------------------------


sub set_pes
{
    # Set the parameters for the pe layout.    

    my $pes_file = shift;
    my $pes_match_ref = shift;
    my $decomp_ref = shift;
    my $pecount_opts = shift;

#    print "tcx1: pecount_opts: $pecount_opts\n";

    # Initialize some local variables
    my $nm = "set_pes"; 
    my %pes_match = %{$pes_match_ref};
    my @matches = keys(%pes_match);
    if ( ref($decomp_ref) ne "HASH" ) { die "ERROR::($nm) input decomp is not a hash!\n"; }

    # Open and read the xml file
    my $xml = XML::Lite->new( $pes_file );
    if ( ! defined($xml) ) {
	die "ERROR($nm): Trouble opening or reading $file\n";
    }
    my $elm  = $xml->root_element( );
    my $root = "pesinfo";
#    my $root = "config_definition";

    my @children = $xml->elements_by_name( $root );
    if ( $#children < 0 ) {
	die "ERROR($nm): could not find the main $root root element in $pes_file\n";
    }
    if ( $#children != 0 ) {
	die "ERROR($nm): $root root element in $file is duplicated, there should only be one\n";
    }
    
    # examine the attributes of each element to determine the "best fit"
    my $possible_match = " ";
    my $pecount_vals = " ";
    for (my $i = 0; $i <= $#children; $i++) {
	#
	# Name of element, and it's associated attributes
	my $child = $children[$i];
	my $name = $child->get_name();
	my @children_level = $child->get_children();
	my $num_children = $#children_level+1;
	
	if ( $#children_level > -1 ) {
	    foreach my $child_level ( @children_level ) {
		
		# Check all the attributes for this element to determine if we have a complete match
		my %atts = $child_level->get_attributes;
		my @keys = keys(%atts);
		my $num_matches = 0;
		foreach my $key ( @keys ) {
		    foreach my $var ( @matches ) {
			my $match = $atts{$key};
                        # Match either the begining or the end of the line
			if ( ($key eq $var)){ 
			   if($var eq "grid_match"  && (($pes_match{$var} =~ /^$match/ ) ||
						($pes_match{$var} =~ /$match$/ ))){
			       $num_matches++; 
			   }elsif ($pes_match{$var} =~ /^$match/ ) {
			       $num_matches++; 
			   }

			    
			}
		    }
		}

                # Keep list of possible pecount attributes
		foreach my $key ( @keys ) {
		    if ($key eq "pecount") {
			if ($pecount_vals =~ /$atts{$key}/){
                            # this is a repeated match
			} else {
			    $pecount_vals = $pecount_vals . "$atts{$key} ";
			    $pecount_vals =~ s/\|/ /g;
			}
		    }
		}

		# Need all the attributes to match in order to read the element pes
		my $num_keys = $#keys + 1;
		if ($num_matches eq $num_keys) {

		    my %atts = $child_level->get_attributes;
		    my @keys = keys(%atts);
		    $possible_match = "";
		    foreach my $key ( @keys ) {
			$possible_match = "$possible_match" . "$key: $atts{$key}\n";
		    }

		    my @decomp_children = $child_level->get_children();
		    if ( $#decomp_children > -1 ) {
			foreach my $decomp_child ( @decomp_children ) {
			    my $name  = $decomp_child->get_name();
			    my $value = $decomp_child->get_text();
			    if ( ! defined($$decomp_ref{$name}) ) {
				die "ERROR($nm): $name is NOT a valid element for the decomp output hash\n";
			    }
			    $$decomp_ref{$name} = $value;
			}
		    } else {
			die "ERROR($nm): No sub-elements for $name \n";
		    }
		}  
	    }
	}
    }

#    print "tcx2: pecount_opts: $pecount_opts\n";
#    print "tcx2: pecount_vals: $pecount_vals\n";
#    print "tcx2: pes_match(pe):$pes_match{'pecount'}\n";
    if ($pecount_opts) {
	if ($pecount_vals =~ /$pes_match{'pecount'}/)  {
	    # do nothing
	} else {
	    die << "EOF";
($0) invalid pecount option: $pes_match{'pecount'}
($0)      valid options are: $pecount_vals
EOF
        }
    }
    print "***********************************************************\n";
#    print "PE layouts are determined by config_pes.xml file \n";
#    print "Some PE layouts are created to match specific \n";
#    print "machine, grid, compset, and pecount options \n";
#    print "and will result in better PE layouts.\n";
#    print "Optimal layouts will match all four options. \n \n";
    print "The PE layout for this case match these options:\n";
    print "$possible_match";
    print "***********************************************************\n\n";
}

#-------------------------------------------------------------------------------

sub set_test
{
    # Set the parameters for the specified testname.  The
    # parameters are read from an input file, and if no testname matches are
    # found then issue error message.
    # This routine uses the configuration defined at the package level ($cfg_ref).

    my ($test_file, $testname, $cfg_ref) = @_;
    my $xml = XML::Lite->new( $test_file );
    my $root = $xml->root_element();

    # Check for valid root node
    my $name = $root->get_name();
    $name eq "config_ccsmtest" or die
	"file $test_file is not a test parameters file\n";

    # Read the test parameters from $test_file.
    my @e = $xml->elements_by_name( "ccsmtest" );
    my %a = ();

    # Search for matching test.
    my $found = 0;
  CCSMTEST:
    while ( my $e = shift @e ) {
	%a = $e->get_attributes();
	if ( ($testname eq $a{'NAME'}) )  {
	    $found = 1;
	    last CCSMTEST;
	}
    }

    # Die unless search was successful.
    unless ($found) { 
	print "set_test: no match for test $testname - possible testnames are \n";
	my @e_err = $xml->elements_by_name( "ccsmtest" );
	my %a_err = ();
	while ( my $e_err = shift @e_err ) {
	    %a_err = $e_err->get_attributes();
	    print " $a_err{'NAME'} ($a_err{'DESC'}) \n" ;
	}
	die "set_test: exiting\n"; 
    }

    # Loop through all entry_ids of the $cfg_ref object and if the corresponding 
    # attributed is defined in the testname hash, then reset the cfg_ref object to
    # that value

     my @ids = keys %$cfg_ref;
     foreach my $id (sort @ids) {
	 foreach my $attr (keys %a) {
             if ( ! $cfg_ref->is_ignore_name($attr) and ! $cfg_ref->is_valid_name($attr) ) { 
                die "set_test: invalid id $attr in test $testname in file $test_file exiting\n"; 
             }
	     if ($attr eq $id) {
	         my $value = $a{$attr};
	         $cfg_ref->set($id, $value);
             }
	 }
     }

}

#-------------------------------------------------------------------------------

sub set_confopts
{
    # Print all currently supported valid grids

    my ($coptions, $cfg_ref) = @_;

    print "***********************************************************\n";
    print "  confopts = $coptions\n";
    if ($coptions =~ "_D" || $coptions =~ "_ED") {
	$cfg_ref->set('DEBUG', "TRUE");
        print "    confopts DEBUG ON \n";
    }
    if ($coptions =~ "_E" || $coptions =~ "_DE") {
	$cfg_ref->set('USE_ESMF_LIB', "TRUE");
	$cfg_ref->set('COMP_INTERFACE', "ESMF");
        print "    confopts COMP_INTERFACE ESMF set \n";
    }
    if ($coptions =~ "_P") {
        my $popt = $coptions;
        $popt =~ s/.*_P([A-Za-z0-9]*)_?.*/$1/;
        $pecount = $popt;
        print "    confopts pecount set to $pecount \n";
    }
    if ($coptions =~ "_N") {
        my $nopt = $coptions;
        $nopt =~ s/.*_N([0-9]*)_?.*/$1/;
	$cfg_ref->set('NINST_ATM', $nopt);
	$cfg_ref->set('NINST_LND', $nopt);
	$cfg_ref->set('NINST_OCN', $nopt);
	$cfg_ref->set('NINST_ICE', $nopt);
	$cfg_ref->set('NINST_GLC', $nopt);
        print "    confopts instances set to $nopt \n";
    }
    if ($coptions =~ "_CG") {
	$cfg_ref->set('CALENDAR', "GREGORIAN");
        print "    confopts CALENDAR set to GREGORIAN \n";
    }
    if ($coptions =~ "_AOA") {
	$cfg_ref->set('AOFLUX_GRID', "atm");
        print "    confopts AOFLUX_GRID set to atm \n";
    }
    if ($coptions =~ "_AOE") {
	$cfg_ref->set('AOFLUX_GRID', "exch");
        print "    confopts AOFLUX_GRID set to exch \n";
    }

    if ($coptions =~ "_R") {
        my $ptsmode = "undef";
        if ($coptions =~ "_RLA" ) {
           $cfg_ref->set('PTS_LAT',  42 );
           $cfg_ref->set('PTS_LON',  260 );
           my $ptsmode = "valid";
           print "    confopts single point mode set to RLA \n";
        }
        if ($coptions =~ "_RLB" ) {
           $cfg_ref->set('PTS_LAT',  -5 );
           $cfg_ref->set('PTS_LON',  290 );
           my $ptsmode = "valid";
           print "    confopts single point mode set to RLB \n";
        }
        if ($coptions =~ "_ROA" ) {
           $cfg_ref->set('PTS_LAT',  30 );
           $cfg_ref->set('PTS_LON',  315 );
           my $ptsmode = "valid";
           print "    confopts single point mode set to ROA \n";
        }
        if ($coptions =~ "_ROB" ) {
           $cfg_ref->set('PTS_LAT',  0 );
           $cfg_ref->set('PTS_LON',  160 );
           my $ptsmode = "valid";
           print "    confopts single point mode set to ROB \n";
        }
        if ($ptsmode ==  "valid" ) {
           $cfg_ref->set('PTS_MODE',      "TRUE" );
           $cfg_ref->set('USE_MPISERIAL', "TRUE" );
           $cfg_ref->set('ATM_NX', 0);
           $cfg_ref->set('ATM_NY', 0);
           $cfg_ref->set('LND_NX', 0);
           $cfg_ref->set('LND_NY', 0);
           $cfg_ref->set('ICE_NX', 0);
           $cfg_ref->set('ICE_NY', 0);
           $cfg_ref->set('OCN_NX', 0);
           $cfg_ref->set('OCN_NY', 0);
           $cfg_ref->set('GLC_NX', 0);
           $cfg_ref->set('GLC_NY', 0);
        } else {
	   print "create_newcase exited on invalid _R confopts setting\n\n";
           exit -1;
        }
    }
    print "***********************************************************\n\n";

}

#-------------------------------------------------------------------------------

sub print_grids
{
    # Print all currently supported valid grids

    my ($grid_file) = @_;
    my $xml = XML::Lite->new( $grid_file );
    my $root = $xml->root_element();

    # Check for valid root node
    my $name = $root->get_name();
    $name eq "config_horiz_grid" or die
	"file $grid_file is not a horizontal grid parameters file\n";

    print ("  \n");
    print ("  RESOLUTIONS:  name (shortname) \n");

    # Read the grid parameters from $grid_file.
    my @e = $xml->elements_by_name( "horiz_grid" );
    my %a = ();
    while ( my $e = shift @e ) {
	%a = $e->get_attributes();
	if (defined($a{'SHORTNAME'})) { 
	    print "    $a{'GRID'} ($a{'SHORTNAME'})  \n";
	    print "       $a{'DESC'} \n";
	}
    }
}

#-------------------------------------------------------------------------------

sub print_compsets
{
    # Print all currently supported valid grids

    my ($compset_file, $grid_longname, $grid_shortname) = @_;
    my $xml = XML::Lite->new( $compset_file );
    my $root = $xml->root_element();

    # Check for valid root node
    my $name = $root->get_name();
    $name eq "config_compset" or die
	"file $compset_file is not a compset parameters file\n";

    print ("  \n");
    print ("  COMPSETS:  name (shortname): description \n");
    
    # Read the compset parameters from $compset_file.
    my @e = $xml->elements_by_name( "compset" );
    my %a = ();
    my $e; 
    while ( $e = shift @e ) {
	%a = $e->get_attributes();
	if ($a{'NAME'}) {
	    print "    $a{'NAME'} ($a{'SHORTNAME'}) \n";
	    print "         $a{'DESC'}  \n";
	}
    }
}

#-------------------------------------------------------------------------------

sub print_tests
{
    # Print all currently supported tests

    my ($test_file) = @_;
    my $xml = XML::Lite->new( $test_file );
    my $root = $xml->root_element();

    # Check for valid root node
    my $name = $root->get_name();
    $name eq "config_ccsmtest" or die
	"file $test_file is not a ccsmtest parameters file\n";

    print ("  \n");
    print ("  TESTS:  name (description) \n");
    
    my @e = $xml->elements_by_name( "ccsmtest" );
    my %a = ();
    while ( my $e = shift @e ) {
	%a = $e->get_attributes();
	if (defined($a{'DESC'})) { 
	    print "    $a{'NAME'} ($a{'DESC'}) \n";
	}
    }
}
