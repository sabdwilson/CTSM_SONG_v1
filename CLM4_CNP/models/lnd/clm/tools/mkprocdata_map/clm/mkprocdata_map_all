#!/bin/bash

# This script runs mkprocdata_map_wrap on all files matching a given
# pattern within a directory.

# Created by Bill Sacks, 5-26-11

# ----------------------------------------------------------------------
# LOCAL FUNCTIONS DEFINED HERE
# ----------------------------------------------------------------------

function Usage {
    script_name=`basename $0`
    echo "Usage: $script_name [-d directory] [-e executable-path] [-h] [-i] [-l] [-o output_suffix] [-s suffix] [-t] prefix fmap ftemplate"
    echo ""
    echo "This script runs mkprocdata_map_wrap on all files matching a"
    echo "given pattern within a directory."
    echo ""
    echo "'prefix' gives the prefix of the files on which"
    echo "mkprocdata_map_wrap should be run; 'prefix' should NOT contain"
    echo "wildcard characters. The prefix is also used to translate"
    echo "from input to output file names (see examples below)"
    echo ""
    echo "'fmap' gives the name (and full path if not in the current"
    echo "directory) of the mapping file"
    echo ""
    echo "'ftemplate' gives the name (and full path if not in the"
    echo "current directory) of the template file, from which we read"
    echo "lats, lons and some other variables"
    echo ""
    echo "The following are optional arguments:"
    echo ""
    echo "[-d directory]: Do the processing in the given directory."
    echo "                If not specified, processing is done in the"
    echo "                current working directory."
    echo ""
    echo "[-e executable-path]: Gives the full path of the"
    echo "                      mkprocdata_map_wrap executable (including"
    echo "                      the name of the executable itself)."
    echo "                      If not specified, the executable is"
    echo "                      assumed to be named mkprocdata_map_wrap,"
    echo "                      in the same directory as this script"
    echo ""
    echo "[-h]: Print this help message and exit"
    echo ""
    echo "[-i]: Ignore (skip) existing output files; if this option is"
    echo "      not specified, then the script dies with an error if"
    echo "      any of the desired output files already exist"
    echo ""
    echo "[-l]: Option passed to mkprocdata_map_wrap"
    echo ""
    echo "[-o output_suffix]: suffix to append to the end of the prefix"
    echo "                    on the output files"
    echo "                    If not specified, '_2d' is used"
    echo ""
    echo "[-s suffix]: Run mkprocdata_map_wrap on all files matching the"
    echo "             pattern '\${prefix}\${suffix}'. The suffix can -"
    echo "             and often will - contain wildcards; but"
    echo "             remember to enclose 'suffix' in quotes to"
    echo "             prevent shell expansion."
    echo "             If not specified, run mkprocdata_map_wrap on all"
    echo "             files matching '\${prefix}*'"
    echo ""
    echo "[-t]: Do a test (dry run): do all error-checking on"
    echo "      arguments and print commands that would be run, but"
    echo "      don't actually run commands"
    echo ""
    echo ""
    echo "Example: $script_name Ib14_ne30np4_gx1v6 map_ne30np4_to_fv1.9x2.5_aave_da_091230.nc Ib19_1.9x2.5_gx1v6.clm2.h0.0001-01.nc"
    echo "This will run mkprocdata_map_wrap on all files whose names begin"
    echo "with 'Ib14_ne30np4_gx1v6' in the current directory, using the"
    echo "mapping file named 'map_ne30np4_to_fv1.9x2.5_aave_da_091230.nc'"
    echo "and the template file named 'Ib19_1.9x2.5_gx1v6.clm2.h0.0001-01.nc'"
    echo "For an input file named:"
    echo "  Ib14_ne30np4_gx1v6.clm2.h0.0001-01-06-00000.nc"
    echo "The output file will be named:"
    echo "  Ib14_ne30np4_gx1v6_2d.clm2.h0.0001-01-06-00000.nc"
    echo ""
    echo "Example: $script_name -o '_remap' -s '*.h0.0001*.nc' Ib14_ne30np4_gx1v6 map_ne30np4_to_fv1.9x2.5_aave_da_091230.nc Ib19_1.9x2.5_gx1v6.clm2.h0.0001-01.nc"
    echo "This will run mkprocdata_map_wrap on all files whose names match"
    echo "the pattern 'Ib14_ne30np4_gx1v6*.h0.0001*.nc', in the"
    echo "current directory, using the mapping file named"
    echo "'map_ne30np4_to_fv1.9x2.5_aave_da_091230.nc' and the"
    echo "template file named Ib19_1.9x2.5_gx1v6.clm2.h0.0001-01.nc"
    echo "For an input file named:"
    echo "  Ib14_ne30np4_gx1v6.clm2.h0.0001-01-06-00000.nc"
    echo "The output file will be named:"
    echo "  Ib14_ne30np4_gx1v6_remap.clm2.h0.0001-01-06-00000.nc"
    echo ""
}

# This function echoes the command given by $1 (cmd), then executes it.
# However, if $2 (dryrun) is non-zero, then it only does the echo, not the execution.
# Usage: do_cmd cmd dryrun
# Returns 0 on success, non-zero on failure; if there is an error, the error string is echoed.
function do_cmd {
    if [[ $# -ne 2 ]]; then
	echo "ERROR in do_cmd: wrong number of arguments: expected 2, received $#"
	return 1
    fi

    cmd=$1
    dryrun=$2

    echo $cmd
    if [ $dryrun -eq 0 ]; then
	# We use 'eval $cmd' rather than just '$cmd', because the
	# latter doesn't work right if the command contains any quoted
	# strings (e.g., svn ci -m "this is my message")
	eval $cmd
	if [ $? -ne 0 ]; then
	    echo "ERROR in do_cmd: error executing command"
	    return 2
	fi
    fi

    return 0
}

# ----------------------------------------------------------------------
# BEGIN MAIN SCRIPT
# ----------------------------------------------------------------------

script_dir=`dirname $0`

# ----------------------------------------------------------------------
# Handle command-line arguments
# ----------------------------------------------------------------------

# define default values:
directory="."
executable="${script_dir}/mkprocdata_map_wrap"
ignore_existing=0
output_suffix="_2d"
suffix="*"
dryrun=0
extra_args=""

while getopts d:e:hilo:s:t opt; do
    case $opt in
	d) directory=$OPTARG;;
	e) executable=$OPTARG;;
	h) Usage; exit;;
	i) ignore_existing=1;;
	l) extra_args="$extra_args -l";;
	o) output_suffix=$OPTARG;;
	s) suffix=$OPTARG;;
	t) dryrun=1;;
	\?) Usage; exit 1
    esac
done

# shift off the arguments we read with getopts:
shift `expr $OPTIND - 1`

if [[ $# -ne 3 ]]; then
    echo "ERROR: Wrong number of arguments"
    echo ""
    Usage
    exit 1
fi

prefix=$1
fmap=$2
ftemplate=$3

# ----------------------------------------------------------------------
# Error checking on arguments
# ----------------------------------------------------------------------

# Make sure the given executable is really an executable
if [ ! -x $executable -o -d $executable ]; then
    echo "ERROR: $executable is not an executable file"
    echo ""
    Usage
    exit 1
fi

# Make sure fmap is really a file
if [ ! -f $fmap ]; then
    echo "ERROR: can't find fmap: $fmap"
    echo ""
    Usage
    exit 1
fi

# Make sure ftemplate is really a file
if [ ! -f $ftemplate ]; then
    echo "ERROR: can't find ftemplate: $ftemplate"
    echo ""
    Usage
    exit 1
fi

# Make sure directory is really a directory
if [ ! -d $directory ]; then
    echo "ERROR: $directory is not a directory"
    echo ""
    Usage
    exit 1
fi


# ----------------------------------------------------------------------
# Change to desired directory
# ----------------------------------------------------------------------

olddir=`pwd`
cd $directory

# ----------------------------------------------------------------------
# Get list of files matching the given pattern; make sure there really
# are some matching files
# ----------------------------------------------------------------------

files=`ls ${prefix}${suffix}`
if [ $? -ne 0 ]; then
    echo "ERROR trying to find files matching: ${prefix}${suffix}"
    echo ""
    Usage
    exit 1
fi

# ----------------------------------------------------------------------
# Loop through files matching the given pattern; run program for each
# ----------------------------------------------------------------------

for infile in $files; do
    outfile=${infile/$prefix/${prefix}${output_suffix}}
    if [ -e $outfile ]; then
	if [ $ignore_existing -eq 0 ]; then
	    echo ""
	    echo "ERROR: output file $outfile already exists"
	    exit 1
	else
	    echo ""
	    echo "WARNING: output file $outfile already exists: skipping"
	    echo ""
	fi
    
    else  # outfile does not exist
	echo ""
	do_cmd "$executable -i $infile -o $outfile -m $fmap -t $ftemplate $extra_args" $dryrun
    fi
done

# ----------------------------------------------------------------------
# Clean up
# ----------------------------------------------------------------------

cd $olddir